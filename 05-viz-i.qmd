---
title: "I: Basics"
image: apple-touch-icon.png
editor_options: 
  chunk_output_type: console
---

:::{.panel-tabset}

# Lesson

- One key part of understanding your data and presenting your analyses lies in making plots, which we will cover through this section of the class

- There are multiple graphing systems in R, but we are going to focus on two (primarily one);
  - [vanilla R plots](https://stat.ethz.ch/R-manual/R-devel/library/graphics/html/00Index.html)
  - [ggplot2](http://ggplot2.tidyverse.org). 

#### Vanilla R Plots

- Vanilla R (i.e., R without any packages loaded) can create some basic plots
  - They aren't the prettiest, so I wouldn't recommend them in reports and papers
    - But, they're super-easy and quick to create, so they're perfect for quickly checking your data during the exploration phase
    
#### `ggplot2` Plots

- `ggplot` or `ggplot2` (ggplot was originally a different library, but doesn't exist anymore)
- The gg stands for [grammar of graphics](http://vita.had.co.nz/papers/layered-grammar.html)
  - This is a whole world of detail to dive into if you want
  - The basic idea is that the graphs are made up of *layers*
    - This allows us to create some really cool and detailed plots
      - I'd strongly recommend `ggplot2` for making plots you want to share
        - Even stata users admit the plots can't match `ggplot2`

## Setup

- We're using two libraries today (plus the vanilla R plot functions)

- [ggplot2](http://ggplot2.tidyverse.org)
- [haven](http://haven.tidyverse.org)

- The [ggplot2](http://ggplot2.tidyverse.org) library is part of the `tidyverse`
  - We don't need to load it separately (we can just use `library(tidyverse)` as always)

- We're also going to use [haven](http://haven.tidyverse.org),
- Also part of the `tidyverse` but not loaded by default, so we have to load it with `library(haven)`
  - Haven allows us to read in data files from other software such as SPSS, SAS, and Stata
    - We'll use it to read in a Stata (`*.dta`) version of the small HSLS data we've used before.
      - The Stata version, unlike the plain `.csv` version, has labels for the variables and values, which will be useful when plotting. 


```{r, include = FALSE, purl = TRUE}
################################################################################
##
## <PROJ> EDH7916: Data visualization with ggplot2
## <FILE> plotting.R 
## <INIT> 9 March 2020
## <AUTH> Benjamin Skinner (GitHub/Twitter: @btskinner)
##
################################################################################

```
```{r}
## ---------------------------
## libraries
## ---------------------------

library(tidyverse)
library(haven)
```

- **Note** that since we have two data files this lesson, we'll give them unique names instead of the normal `df`:

- `df_hs` := `hsls_small.dta`
- `df_ts` := `all_schools.csv`

```{r}
## ---------------------------
## input data
## ---------------------------

## read_dta() ==> read in Stata (*.dta) files
df_hs <- read_dta(file.path("data", "hsls-small.dta"))
## read_csv() ==> read in comma separated value (*.csv) files
df_ts <- read_csv(file.path("data", "sch-test", "all-schools.csv"))
```

## Plots using base R

```{r, echo = FALSE, purl = TRUE}
## -----------------------------------------------------------------------------
## Base R graphics
## -----------------------------------------------------------------------------
```

- Even though new graphics libraries have been developed, the base R graphics system remains powerful
- The base system is also very easy to use in a pinch
  - When I want a quick visual of a data distribution that's just for me, I often use base R

- **Note** that for the next few plots, I'm not much concerned with how they look
  - Specifically, the axis labels won't look very nice
  - We could spend time learning to make really nice base R plots for publication
    - But I'd rather we spend that time with ggplot2 graphics.

- **Also note** that we'll have to switch to using the vanilla R data frame `$` notation to pull out the columns we want
  - In short, to reference a column in a data frame in vanilla R, you say `dataframe$column`
  - If you need some more information on using `$` notation, [check out the supplemental lesson on data wrangling with vanilla R](x-03-pro-vanilla.qmd).

### Histogram

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## histogram
## ---------------------------
```

- For continuous variables, a histogram is a useful plot
- Though the `hist()` function has many options to adjust how it looks
  - The default settings work really well if you just want a quick look at the distribution.

```{r eda_base_histogram}
## histogram of math scores (which should be normal by design)
hist(df_hs$x1txmtscor)
```

> #### Quick exercise
> Check the distribution of the students' socioeconomic score (SES).

### Density 

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## density
## ---------------------------
```

- Density plots are also really helpful for checking the distribution of a variable
- Vanilla R doesn't have formal density plot function, but you can get a density plot with a trick
  - `plot()` the `density()` of a continuous variable

> Quick question: What does the `na.rm = TRUE` and why might we need it?

```{r eda_base_density}
## density plot of math scores
## read inside out: get density value, then plot values
plot(density(df_hs$x1txmtscor, na.rm = TRUE))
```

> #### Quick exercise
> First, plot the density of SES
> Then, add the `col` argument in `plot()` to change the color of the line to `"red"`

### Box plot

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## box plot
## ---------------------------
```

- A box plot will let you see the distribution of a continuous variable at specific values of a categorical variable
  - For example, test scores ranges at each student expectation level

- Call a box plot using the `boxplot()` function
  - This one is a little trickier because it uses the [R formula](https://www.statmethods.net/graphs/boxplot.html) construction
to set the continuous variable against the discrete variable
  - The formula uses a tilde, `~`, and should be constructed like this:
    - `<continuous var> ~ <discrete var>`
    - We will talk in more detail about formulas in the [Programming: Modeling Basics lesson](12-pro-model.qmd)
  - As we are using a formula, notice how we can use the `data = df_hs` argument instead of adding `df_hs$` in front of the variable names, which saves some typing

```{r eda_base_box}
## box plot of math scores against student expectations
boxplot(x1txmtscor ~ x1stuedexpct, data = df_hs)
```

From the boxplot, we can see that math test scores tend to increase as students' educational expectations increase (remember that 11 means "I don't know [how far I'll go in school]"), though there's quite a bit of overlap in the marginal distributions.

### Scatter

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## scatter
## ---------------------------
```

- Plot two continuous variables against one another using the base `plot()` function
- The main way to make a scatter plot is `plot(x, y)`
  - The `x` is the variable that will go on the x-axis and `y` the one that will go on the y-axis

```{r eda_base_scatter}
## scatter plot of math against SES
plot(df_hs$x1ses, df_hs$x1txmtscor)
```

From the scatter plot we see the data seem to show a positive correlation between socioeconomic status and math test score, there's also quite a bit of variation in that association (notice that the cloud-like nature of the circles). 

> #### Quick exercise 
> Rerun the above plot, but this time store it in an object,
> `plot_1`, then get the plot to print out

## Plots using `ggplot2`

```{r, echo = FALSE, purl = TRUE}
## -----------------------------------------------------------------------------
## Graphics with ggplot2
## -----------------------------------------------------------------------------
```

- `ggplot2` is my --- and many R users' --- primary system for making plots
- It is based on the idea of a [grammar of graphics](https://www.springer.com/gp/book/9780387245447)
  - Just as we can use finite rules of a language grammar to construct an endless number of unique sentences, so too can we use a few graphical grammatical rules to make an endless number of unique figures.

- The [ggplot2 system](http://ggplot2.tidyverse.org/reference/) is too involved to cover in all of its details
  - But that's kind of the point of the grammar of graphics
  - Once you see how it's put together, you can anticipate the commands you need to build your plot.

- We'll start by covering the same plots as above.

### Histogram

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## histogram
## ---------------------------
```

[As the main help site says](http://ggplot2.tidyverse.org), all
ggplot2 plots need three things:

- **[data]**: The source of the variables you want to plot
- **[aesthetics]**: How variables in the data map onto the plot (_e.g._, what's on the x-axis? what's on the y-axis?)
- **[geom]**: The geometry of the figure or the kind of figure you want to make (_e.g._, what do you want to **do** with those data and mappings? A line graph? A box plot?...)

- We'll start by making a histogram again
- To help make these pieces clearer, I'll use the argument names when possible
  - As you become familiar, you probably will stop naming some of these core arguments
- The first function, which initializes the plot is `ggplot()`
  - Its first argument is the data, which want to use `df_hs`

```{r eda_plot_histogram_blank, warning = F, message = F}
## init ggplot 
ggplot(data = df_hs)
```

- ...nothing! Well, not nothing, but no histogram.
  - That's because the plot knows the data but doesn't know what do with it. What do we want?
- Since we want a histogram, we add the `geom_histogram()` function to the existing plot object with a plus sign(`+`). Once we do that, we'll try to print the plot again...
- The aesthetic mappings, that is, which variables go where or how they function on the plot, go inside the `aes()` function. 
  - Since we only have one variable, `x1txmtscor`, it is assigned to `x`.

```{r eda_plot_histogram, warning = F, message = F}
## add histogram instruction (notice we can add pieces using +)
ggplot(data = df_hs) +
  geom_histogram(mapping = aes(x = x1txmtscor))
```

Success!

> Quick excercise: try assigning the historgram to an object, then getting it to print out

- As you can see, the code to make a ggplot2 figure looks a lot like what we've seen with other tidyverse libraries, _e.g._ dplyr.
- The key difference between ggplot2 and our previous code, however, is that 
  - Up to now we have used the pipe (`|>`) to pass output to the next function
  - ggplot2 uses a plus sign (`+`) add new layers to the plot
  
- Layers is exactly how you want to think about ggplots
  - The `ggplot()` is the base layer of the graph
    - Anything you place in here will become the default for every other layer
      - For example, if we say `data = df` in `ggplot()`, that will be the default data for every layer
        - Generally I specify the data here, and `mapping = aes()` in the specific plots

> Quick question(s): Why might that make sense? Which is more likely to change? Are there times you might want to set an aesthetic for the whole plot?


### Density

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## density
## ---------------------------
```

- Unlike the base R graphics system, ggplot2 does have a density plotting command `geom_density()`
  - The rest of the code remains the same as for `geom_histogram()`

```{r eda_plot_density, warning = F, message = F}
## density
ggplot(data = df_hs) +
  geom_density(mapping = aes(x = x1txmtscor))
```

> #### Quick exercise
> If we wanted to see the histogram and density plot on top of each other, what might we do? Give it a go, and, tell me why it didn't work...

```{r}
ggplot(data = df_hs) +
  geom_histogram(mapping = aes(x = x1txmtscor)) +
  geom_density(mapping = aes(x = x1txmtscor))
```

- The issue is that the histogram y scale is much much larger than the density
  - To fix that, let's modify the `geom_histogram()` aesthetic to use the `density` function rather than the raw counts
    - We use the `after_stat()` function, which basically means after ggplot calculates the statistics, it converts them to density

```{r eda_plot_histdens, warning = F, message = F}
## histogram with density plot overlapping
ggplot(data = df_hs) +
  geom_histogram(mapping = aes(x = x1txmtscor, y = after_stat(density))) +
  geom_density(mapping = aes(x = x1txmtscor))
```

- It worked, but it's not the greatest visual since the colors are the same and the density plot is thin with no fill. 

- Adding to what came before, the `geom_histogram()` and `geom_density()` both take on new arguments that change the defaults
- Now the resulting plot should look nicer and be easier to read

```{r eda_plot_histdens_2, warning = F, message = F}
## histogram with density plot overlapping (add color to see better)
ggplot(data = df_hs) +
  geom_histogram(mapping = aes(x = x1txmtscor, y = after_stat(density)),
                 color = "black",
                 fill = "white") +
  geom_density(mapping = aes(x = x1txmtscor),
               fill = "red",
               alpha = 0.2)

```

> #### Quick exercise
> Try changing some of the arguments in the last plot. What happens when you change `alpha` (keep the value between 0 and 1)? What does the `color` argument change? And `fill`? What happens if you switch the `geom_*()` functions, call `geom_histogram()` after you call `geom_density()`?

- A critical thing to note, in the previous plot `color`, `fill`, and `alpha` were all outside the `aes()`
  - This means they take a single value and apply it uniformly, it should portray no information and just change the appearance
  - To use these elements to portray information, we need to place the arguments inside `aes()` like we will do in the next plot

### Two-way

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## two way plot
## ---------------------------
```

- Plotting the difference in a continuous distribution across groups is a common task
- Let's see the difference between student math scores between students with parents who have any postsecondary degree and those without. 

- Since we're using data that was labeled in Stata, we'll see the labels when we use `count()`

```{r}
## see the counts for each group
df_hs |> count(x1paredu)
```

- We can see that all values of `x1paredu` greater than 2 represent parents with some college credential
  - Since we want only two distinct groups, we can use `mutate`, `ifelse` and the operator `>=` to make a new 0/1 binary variable.     - If a value of `x1paredu` is above 3, then the new indicator `pared_coll` will be 1; if not, 0.

**NOTE** that in the Stata version of `hsls_small`, all the missing values, which are normally negative numbers, have already been properly converted to `NA` values. That's why we see a count column for `NA` and not labels for missingness that we might have expected based on prior lessons.

- The `ggplot()` function doesn't need to use our full data
- In fact, our data needs to be set up a bit differently to make this plot
  - This is a common thing people forget when plotting, data wrangling lessons [one](03-wrangle-i.qmd) and [two](04-wrangle-ii.qmd) are your friend here
- We'll make a new temporary data object that only has the data we need.

- Notice, after we create `pared_coll`, we use the `factor()` command to make it a factor type of variable
  - This is R's built in way of handling categorical variables (i.e., so that is doesn't think it's continuous)
  - Creating factors is really useful for plotting, and later on for statistical models


```{r}
## need to set up data
plot_df <- df_hs |>
    ## select the columns we need
    select(x1paredu, x1txmtscor) |>
    ## can't plot NA so will drop
    drop_na() |>
    ## create new variable that == 1 if parents have any college, then make it a factor
    mutate(pared_coll = ifelse(x1paredu >= 3, 1, 0),
           pared_coll = factor(pared_coll)) |>
    ## drop (using negative sign) the original variable we don't need now
    select(-x1paredu) 

## show
head(plot_df)
```

- To plot against the two groups we've made, we need to add it to the aesthetic feature, `aes()`
- The math score, `x1txmtscor`, is still mapped to `x`
- Since we want two side-by-side histograms, we set the `fill` aesthetic to our new indicator variable

```{r eda_plot_histogram_double, warning = F, message = F}
## two way histogram
ggplot(plot_df) +
  geom_histogram(aes(x = x1txmtscor,
                     fill = pared_coll),
                 alpha = 0.5,
                 color = "black")
```

- By assigning `pared_coll` to the `fill` aesthetic, we can see a difference in the distribution of math test scores between students whose parents have at least some college and those whose parents do not
  - Note: there are more students with no parental college education, so that whole histogram is bigger
    - If we want to compare the shape of distribution more easily, we should use `geom_density()`

```{r eda_plot_histogram_double, warning = F, message = F}
## two way histogram
ggplot(plot_df) +
  geom_density(aes(x = x1txmtscor,
                     fill = pared_coll),
                 alpha = 0.5,
                 color = "black")
```

> #### Quick question
> Why does the `color = "black"` not mean we have two black density/histogram plots? What happens if you remove it? Can you make it `<something else> = "black"` to get rid of the colors? 

### Box plot

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## box plot
## ---------------------------
```

- By this point, you're hopefully seeing the pattern in how ggplot2 figures are put together
- To make a box plot, we need to add a `y` mapping to the `aes()` in addition to the `x` mapping
- We've also added the same variable to `fill` as we did to `x`
  - We do this so that in addition to having different box and whisker plots along the x-axis, each plot is given its own color
- Notice: this time, we just threw `factor()` around the variable in the plot, rather than using mutate to change the data

> Quick question: What do you think the pros and cons of using `factor()` in the plot over mutating the data might be?


```{r eda_plot_box, warning = F, message = F}
## box plot using both factor() and as_factor()
ggplot(data = df_hs,
       mapping = aes(x = factor(x1paredu),
                     y = x1txmtscor,
                     fill = factor(x1paredu))) +
  geom_boxplot()
```

- In a way, this plot is similar to the dual histogram above
  - But since we want to see the distribution of math scores across finer-grained levels of parental education, the box and whisker plot is clearer than trying to overlap seven histograms.

> #### Quick exercise
> We will get more into making things look pretty in [Data Vizualization II](06-viz-ii.qmd), but, what is a real problem with this graph? Does it even need to be there?

### Scatter

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## scatter plot
## ---------------------------
```

- To make a scatter plot, make sure that the `aes()` has mappings for the `x` axis and `y` axis and then use `geom_point()` to plot.
- To make things easier to see (remembering the over-crowded cloud from the base R plot above), we'll reduce the data to 10% of the full sample using `sample_frac()` from dplyr
- We'll also limit our 10% to those who aren't missing information about student education expectations

```{r eda_plot_scatter_1, warning = F, message = F}
## sample 10% to make figure clearer
df_hs_10 <- df_hs |>
    ## drop observations with missing values for x1stuedexpct
    drop_na(x1stuedexpct) |>
    ## sample
    sample_frac(0.1)

## scatter
ggplot(data = df_hs_10) +
  geom_point(mapping = aes(x = x1ses, y = x1txmtscor))
```

- Now that we have our scatter plot, let's say that we want to add a third dimension
  - Specifically, we want to change the color of each point based on whether a student plans to earn a Bachelor's degree or higher
    - That means we need a new dummy variable that is 1 for those with BA/BS plans and 0 for others.

We can look at the student base year expectations with `count()`:

```{r}
## see student base year plans
df_hs |>
    count(x1stuedexpct)
```

- We see that `x1stuedexpct >= 6` means a student plans to earn a Bachelor's degree or higher.
- But since we need to account for the fact that 11 means "I don't know", we need to make sure our test includes `x1stuedexpct < 11`
- Remember from a prior lesson that we can connect these two statements together with the operator `&`
- Let's create our new variable
  - Notice this time when I create the factor, I specify `levels` and `labels`
    - This applies labels much like the `haven` version of our data has, which will print out in our plot

```{r}
## create variable for students who plan to graduate from college
df_hs_10 <- df_hs_10 |>
    mutate(plan_col_grad = ifelse(x1stuedexpct >= 6 & x1stuedexpct < 11,
                                  1,        # if T: 1
                                  0),       # if F: 0
           plan_col_grad = factor(plan_col_grad,
                                  levels = c(0, 1),
                                  labels = c("No", "Yes")))      
```

- Now that we have our new variable `plan_col_grad`, we can add it the `color` aesthetic, `aes()` in `geom_point()`.

```{r eda_plot_scatter_2, warning = F, message = F}
## scatter
ggplot(data = df_hs_10,
       mapping = aes(x = x1ses, y = x1txmtscor)) +
  geom_point(mapping = aes(color = plan_col_grad), alpha = 0.5)

```

> #### Quick exercise
> Remake the plot so the variables on each axis are flipped

### Fitted lines

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## fitted lines
## ---------------------------
```

- It's often helpful to plot fitted lines against a scatter plot to help see the underlying trend
  - There are a number of ways to do this with the `geom_smooth()` function

#### Linear fit

- Setting `method = lm` in `geom_smooth()` will fit a simple straight line of best fit with 95% confidence interval shaded around it.
- Since we want the points and the line to share the same `x` and `y` aesthetics, let's put them in the `ggplot()` base layer

```{r eda_plot_scatter_3, warning = F, message = F}
## add fitted line with linear fit
ggplot(data = df_hs_10, mapping = aes(x = x1ses, y = x1txmtscor)) +
    geom_point(mapping = aes(color = factor(plan_col_grad)), alpha = 0.5) +
    geom_smooth(method = lm, color = "black")
```

#### Loess

- Finally, we can skip trying to adjust a linear line and just fit a [LOESS](https://en.wikipedia.org/wiki/Local_regression) curve, which is a smooth line produced by fitting a large number of local polynomial regressions on subsets of the data.

```{r eda_plot_scatter_5, warning = F, message = F}
## add fitted line with loess
ggplot(data = df_hs_10, mapping = aes(x = x1ses, y = x1txmtscor)) +
    geom_point(mapping = aes(color = factor(plan_col_grad)), alpha = 0.5) +
    geom_smooth(method = loess, color = "black")
```

- To be clear, these semi-automated lines of best fit should not be used to draw final conclusions about the relationships in your data
- You will want to do **much more** analytic work to make sure any correlations you observe aren't simply spurious and that fitted lines are telling you something useful
- That said, fitted lines via `ggplot2` can be useful when first trying to understand your data or to more clearly show observed trends.

### Line graph

```{r, echo = FALSE, purl = TRUE}
## ---------------------------
## line graph
## ---------------------------
```

- When you want to show changes in one variable as a function of another variable
  - _e.g._, changes in test scores over time
- A line graph is often a good choice.
- Since our `hsls_small` data is cross-sectional, we'll shift to using our school test score data `df_ts` from [Data Wrangling II](04-wrangle-ii.qmd)


> Quick question: What does cross-sectional mean? What is the opposite of it?

- As a reminder, here's what the data looks like

```{r}
## show test score data
df_ts
```

#### Simple Line-Graph

- To keep it simple for our first line plot, we'll filter our plot data to keep only scores for one school
  - Notice how we can do that directly with pipes inside the `ggplot()` function
- We want to see changes in test scores over time, so we'll map
  - `year` to the `x` axis
  - `math` to the `y` axis
- To see a line graph, we add `geom_line()`.
-Also notice: since we are going to build this up in layers over a few steps, we are going to assign it to the object `p`

```{r, warning = F, message = F}
## line graph
p <- ggplot(data = df_ts |> filter(school == "Spottsville"),
            mapping = aes(x = year, y = math)) +
    geom_line()
p
```

> #### QUICK EXERCISE 
> Change the school in `filter()` to "East Heights" and then "Bend
> Gate".

#### Multiple-Line Graphs

Easy enough, but let's say that we want to add a third dimension ---
to show math scores for each school in the same plot area. To do this,
we can map a third aesthetic to `school`. [Looking at the help file
for
`geom_line()`](https://ggplot2.tidyverse.org/reference/geom_path.html#aesthetics),
we see that lines (a version of a path) can take `colour`, which means
we can change line color based on a variable. 

The code below is almost exactly the same as before less two things:

1. We don't filter `df_ts` this time, because we want all schools
2. We add `colour = school` inside `aes()`

```{r, warning = F, message = F}
## line graph for math scores at every school over time
p <- ggplot(data = df_ts,
            mapping = aes(x = year, y = math, colour = school)) +
    geom_line()
p
```

This is nice (though maybe a little messy at the moment) because it
allows us to compare math scores across time across schools. But we
have two more test types --- reading and science --- that we would
like to include as well. One approach that will let us add yet another
dimension is to use facets.

### Facets

With facets, we can put multiple plots together, each showing some
subset of the data. For example, instead of plotting changes in math
scores across schools over time on the same plot area (only changing
the color), we can use `facet_wrap()` to give each school its own
little plot. You might hear me or other refer to plots like this a
showing _small multiples_ or as _small multiples_ figures.

Compared to the code just above, notice how we've removed
`colour = school` from `aes()` and included `facet_wrap(~
school)`. The tilde (`~`) works like the tilde in `plot(y ~ x)` above:
it means "plot against or by _X_". In this case, we are plotting math
test scores over time _by_ each school.

```{r, warning = F, message = F}
## facet line graph
p <- ggplot(data = df_ts,
            mapping = aes(x = year, y = math)) +
    facet_wrap(~ school) +
    geom_line()
p
```

Is this faceted plot better than the color line plot before it? To my
eyes, it's a little clearer, but not so much so that I couldn't be
convinced to use the first one. Whether you use the first or the
second would largely depend on your specific data and presentation
needs.

Faceting has a clearer advantage, however, when you want to include
the fourth level of comparison: (1) scores across (2) time across (3)
schools from (4) different tests. To make this comparison, we first
need to reshape our data, which is only long in `year`, to be long in
`test`, too. As we've already seen in a past lesson, we'll use
`pivot_longer()` to place each test type in its own column (`test`)
with the `score` next to it.


```{r}
## reshape data long
df_ts_long <- df_ts |>
    pivot_longer(cols = c("math","read","science"), # cols to pivot long
                 names_to = "test",                 # where col names go
                 values_to = "score")               # where col values go

## show
df_ts_long
```

> #### QUICK EXERCISE
> If we have 4 schools, 6 years, and 3 tests, how many observations
> should `df_ts_long` have in total? Does it?

With our reshaped data frame, we now reintroduce `colour` into the
`aes()`, this time set to `test`. We make one other change: `y =
score` now, since that's the column for test scores in our reshaped
data. All else is the same.

```{r, warning = F, message = F}
## facet line graph, with colour = test and ~school
p <- ggplot(data = df_ts_long,
            mapping = aes(x = year, y = score, colour = test)) +
    facet_wrap(~ school) +
    geom_line()
p
```

Well, it worked...we can see each school's different test score trends
over time, with each school in its own facet and test scores set to a
different color. But the result is a bit underwhelming. Because the
different test types are such different scales (even though they are
normed within themselves), within-test changes seem rather flat over
time.

Let's try something different: in the next figure, we'll swap the
variables we give to `colour` and within `facet_wrap()`. This means
that each test should have its own facet and each line will represent
a different school.

```{r, warning = F, message = F}
## facet line graph, now with colour = school and ~test
p <- ggplot(data = df_ts_long,
            mapping = aes(x = year, y = score, colour = school)) +
    facet_wrap(~ test) +
    geom_line()
p
```

Okay. New problem. While it's maybe a _little_ easier to see same-test
differences across schools over time, the different scales of the
tests still make the figure less useful than we might hope. It's not
that the students are _way_ better at science than reading; it's just
that the tests are scaled differently. Someone quickly reading this
figure, however, might make that incorrect interpretation.

One thing we can do is change the y-axis for each facet. The default is
to keep the y-axis scale the same. By adding `scales = "free_y"` to
`facet_wrap()`, we'll let each test have its own y-axis scale.

Having different axis scales side-by-side can be confusing, however
(this is why the default is to keep them the same). To mitigate that
confusion, we'll also rearrange the facets so they stack rather than
sit side by side. To do this, we'll add `ncol = 1` to
`facet_wrap()`. This says our facets have to stick to one column,
effectively meaning they will stack vertically.

```{r, warning = F, message = F}
## facet line graph, with one column so they stack
p <- ggplot(data = df_ts_long,
            mapping = aes(x = year, y = score, colour = school)) +
    facet_wrap(~ test, ncol = 1, scales = "free_y") +
    geom_line()
p
```

That looks better! But we can do even better than that...

Currently, each test score is on its own normed scale. While our new
figure allows us to make comparisons across schools over time _within_
test, it's more difficult to make a good comparison _between_
tests. For example, East Heights has a little over 20 point drop in
reading scores from 1981 to 1982 and about the same drop in science
scores from 1982 to 1983. How should we think about these drops? Are
they about the same or is one drop relatively bigger than the other?

To better answer this question, we could re-standardize each test
score so that it is centered at 0 and a one unit change is equal to 1
standard deviation difference in score. We'll use `mutate()` to create
a new variable `score_std`. Because we `group_by()` `test`,
`score_std` will be standardized within test.

```{r}
## rescale test scores
df_ts_long <- df_ts_long |>
    group_by(test) |>
    mutate(score_std = (score - mean(score)) / sd(score)) |>
    ungroup()
```

We'll repeat the same code as before, but this time substitute `y =
score_std`. Because all tests are on the same standardized scale, we
can also drop `scales = "free_y"`.

```{r, warning = F, message = F}
## facet line graph with standardized test scores
p <- ggplot(data = df_ts_long,
            mapping = aes(x = year, y = score_std, colour = school)) +
    facet_wrap(~ test, ncol = 1) +
    geom_line()
p
```

Notice the lines look the same relative to one another, but now we
have a consistent scale to help judge changes. To answer our question
from before, it seems that the drop in reading scores (1981 to 1982)
and science scores (1982 to 1983) were each about 1.5 standard
deviations. We could test more formally, but we have a clearer idea
now that all tests are on the same scale.

> #### QUICK EXERCISE
> What happens if you use the argument `scales = "free_y"` in the last
> bit of code? Why might you not use that once we've scaled the test
> scores?

As a quick change, we can go back to having each school in its own
facet and test scores within.

```{r, warning = F, message = F}
## facet line graph
p <- ggplot(data = df_ts_long,
            mapping = aes(x = year, y = score_std, colour = test)) +
    facet_wrap(~ school) +
    geom_line()
p
```

> #### QUICK EXERCISE
> Why did we drop `ncol = 1` from `facet_wrap()`? What happens if you
> keep it?

Our plot is looking better, but it still may not contain the
information we want. We've standardized the test scores over this time
window, but maybe what we really want to know is how they've _changed
relative to the beginning of the sample period_. You can imagine a
superintendent who took over in 1981 would be keen to know how scores
have changed during their tenure.

This means that while we still want to standardize the scores, we
should zero them not at the overall mean, but at the value in the first
year. We can do that by grouping by `school` and `test`, arranging in
year order, making a new variable that is the `first()` score (within
test, within school) and using that rather than the mean test score to
make our new variable, `score_std_sch`.

```{r}
## standardize test scores within school to first year
df_ts_long <- df_ts_long |>
    group_by(test, school) |>
    arrange(year) |> 
    mutate(score_year_one = first(score),
           ## note that we're using score_year_one instead of mean(score)
           score_std_sch = (score - score_year_one) / sd(score)) |>
    ungroup()
```

Now we'll plot using our new variable `score_std_sch`.

```{r, warning = F, message = F}
## facet line graph
p <- ggplot(data = df_ts_long,
            mapping = aes(x = year, y = score_std_sch, colour = test)) +
    facet_wrap(~ school) +
    geom_line()
p
```

With this final graph, we can see relative changes across schools,
across times, across tests. Notice that line shapes within each facet
are the same as before, just shifted up or down so that the first
value for each test in 1981 is 0. 

Is this the best version of this figure (minus making the axis and
legend labels look nicer)?  Again, it depends on what you want to
show. Remember that figures don't speak for themselves: it's up to you
to explain to your reader (include your future self) what they
mean. That said, a well crafted figure will make that job much easier.

```{r, echo = FALSE, purl = TRUE}

## =============================================================================
## END SCRIPT
################################################################################
```


# Assignment

Using the `hsls_small.dta` data set (the Stata version) and the online
codebook, make plots that help answer each of the following
questions. You **do not** need to save the final plot. Throughout, you
**should** account for missing values by dropping them.

For each question, show your data work and write 1-2 sentence(s) in a
comment that describes the relationship your plot shows (_i.e._, how
it answers the question).

## Questions

1. What is the distribution of household size among students in the
   sample?
2. How does student socioeconomic status differ between students who
   ever attended college and those who did not?
3. How do parental educational expectations differ across region?
4. How does the relationship between socioeconomic status and math
   test score differ across region (use a smoothing line to help show
   any relationship)?
5. Among students who ever attended college, how does socioeconomic
   status differ between those who delayed postsecondary enrollment
   and those who did not delay, when delay is defined as:
   i. more than 6 months between high school graduation and
     postsecondary enrollment?
   ii. more than 12 months?

#### Submission details

- Save your script (`<lastname>_assignment_5.R`) in your `scripts`
  directory.
- Push changes to your repo (the new script and new folder) to GitHub
  prior to the next class session.

:::